// Copyright (c) 2025 JoeGlenn1213
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package ignore

import (
	"os"
	"path/filepath"
	"strings"
)

// Template represents a gitignore template
type Template struct {
	Type    ProjectType
	Content string
}

// GetTemplate returns the gitignore template for a project type
func GetTemplate(projectType ProjectType) string {
	switch projectType {
	case ProjectTypePython:
		return pythonTemplate
	case ProjectTypeGo:
		return goTemplate
	case ProjectTypeNode:
		return nodeTemplate
	case ProjectTypeJava:
		return javaTemplate
	case ProjectTypeRust:
		return rustTemplate
	case ProjectTypeAI:
		return aiTemplate
	default:
		return universalTemplate
	}
}

// GenerateGitignore creates a .gitignore file in the specified directory
func GenerateGitignore(dir string, projectType ProjectType) error {
	template := GetTemplate(projectType)

	// Always prepend universal rules
	if projectType != ProjectTypeUnknown {
		template = universalTemplate + "\n# " + strings.Title(string(projectType)) + " specific\n" + template
	}

	gitignorePath := filepath.Join(dir, ".gitignore")
	return os.WriteFile(gitignorePath, []byte(template), 0644)
}

// EnsureGitignore checks if .gitignore exists, if not, detects project type and creates one
// Returns the project type detected and any error
func EnsureGitignore(dir string) (ProjectType, error) {
	if HasGitignore(dir) {
		return ProjectTypeUnknown, nil // Already exists, do nothing
	}

	result := DetectProjectType(dir)
	err := GenerateGitignore(dir, result.Type)
	return result.Type, err
}

// Template definitions
const universalTemplate = `# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Editor directories and files
.idea/
.vscode/
*.swp
*.swo
*~
*.sublime-workspace

# Environment and secrets
.env
.env.local
.env.*.local
*.key
*.pem
id_rsa
id_rsa.pub

# Logs
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Temp files
*.tmp
*.temp
.tmp/
.temp/
`

const pythonTemplate = `# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
venv/
.venv/
ENV/
env/
.env/

# Distribution / packaging
build/
dist/
*.egg-info/
.eggs/
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Jupyter Notebook
.ipynb_checkpoints/
`

const goTemplate = `# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary
*.test

# Output of the go coverage tool
*.out

# Go workspace file
go.work

# Vendor directory (optional, uncomment if not vendoring)
# vendor/
`

const nodeTemplate = `# Dependencies
node_modules/
.pnp/
.pnp.js

# Build outputs
dist/
build/
out/
.next/
.nuxt/
.output/
.cache/

# Testing
coverage/

# Package manager files
.npm
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz

# Misc
*.tsbuildinfo
.eslintcache
`

const javaTemplate = `# Compiled class files
*.class

# Log files
*.log

# Package files
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties

# Gradle
.gradle/
build/
!gradle/wrapper/gradle-wrapper.jar

# IDE
*.iml
.idea/
*.ipr
*.iws
`

const rustTemplate = `# Generated by Cargo
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave for libraries
# Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these
*.pdb
`

const aiTemplate = `# Jupyter Notebook
.ipynb_checkpoints/

# Model files (large binaries)
*.pt
*.pth
*.onnx
*.h5
*.hdf5
*.pkl
*.pickle
*.joblib
*.safetensors
*.gguf
*.bin
*.ckpt

# Model directories
models/
checkpoints/
weights/
saved_models/

# Data directories (often large)
data/
datasets/
*.csv
*.parquet
*.arrow

# Experiment tracking
wandb/
mlruns/
runs/
lightning_logs/

# Hugging Face cache
.cache/
transformers_cache/
`
